<<<<<<< HEAD
/*
  ================================================================
  =                  CascadaPrueba.ino (COMPLETO)               =
  =      Control de robot bípedo con balanceo + seguidor de     =
  =      línea en arquitectura de doble lazo (cascada).          =
  ================================================================

  Este código implementa:
  - Control de balanceo en cascada (PID de ángulo + PID velocidad)
  - Seguidor de línea con 8 sensores IR
  - Tareas FreeRTOS:
        * TaskBalanceo (Core 1, ~50 Hz)
        * TaskLinea    (Core 0, ~10 Hz)
  - Encoders en interrupción
  - Complementary filter para estimar ángulo a partir del MPU6050
  - PWM a 20 kHz con LEDC

  Toda la funcionalidad se encuentra completamente integrada.
*/

#include <Arduino.h>
#include <Wire.h>
#include <MPU6050.h>
#include <driver/ledc.h>
#include <PID_v1.h>

// ==============================================================
// ========================== PINES MOTORES ======================
// ==============================================================
#define AIN1 7
#define AIN2 6
#define PWMA 5
#define BIN1 16
#define BIN2 17
#define PWMB 18
#define STBY 15

// ==============================================================
// ============================== PWM ============================
// ==============================================================
#define PWM_FREQ 20000
#define PWM_RES 8

const ledc_channel_t CH_A = LEDC_CHANNEL_0;
const ledc_channel_t CH_B = LEDC_CHANNEL_1;

// ==============================================================
// ========================== ENCODERS ===========================
// ==============================================================
#define R_A 3
#define R_B 46
#define L_A 9
#define L_B 11

volatile long countR = 0;
volatile long countL = 0;

const float PPR = 44.0f * 119.0f;  // Pulses per revolution reales

// ==============================================================
// =========================== MPU6050 ===========================
// ==============================================================
MPU6050 mpu;

float ax_offset = 0, ay_offset = 0, az_offset = 0;
float gx_offset = 0;

float angleFiltered = 0;

// ==============================================================
// ===================== CONTROL EN CASCADA ======================
// ==============================================================

float setpoint_angle = 0.0;

// PID ÁNGULO
float Kp_angle = 80;
float Ki_angle = 0.9;
float Kd_angle = 1.8;

float angle_integral = 0;
float angle_prev_error = 0;

// PID VELOCIDAD
float Kp_speed = 0.7;
float Ki_speed = 0.0004;
float speed_integral = 0;

// Límites
float MAX_ANGLE = 40;
float PWM_LIMIT = 255;

// ==============================================================
// ===================== SEGUIDOR DE LÍNEA =======================
// ==============================================================

#define NUM_SENSORS 8
const uint8_t sensorPins[NUM_SENSORS] = {40, 38, 37, 36, 35, 0, 45, 48};

volatile float factor_giro = 0.0;

double lineInput = 0;
double lineOutput = 0;
double lineSetpoint = 350;

double Kp_line = 40;
double Ki_line = 0;
double Kd_line = 12;

PID pidLinea(&lineInput, &lineOutput, &lineSetpoint, Kp_line, Ki_line, Kd_line, DIRECT);

// ==============================================================
// ======================== ISRs ENCODERS ========================
// ==============================================================

void IRAM_ATTR isr_RA() {
  if (digitalRead(R_A) == digitalRead(R_B)) countR++;
  else countR--;
}

void IRAM_ATTR isr_LA() {
  if (digitalRead(L_A) == digitalRead(L_B)) countL++;
  else countL--;
}

// ==============================================================
// ======================== PWM MOTORES ==========================
// ==============================================================

void setupMotorPWM(int pwmPin, int pwmChannel, int timerNum) {
  ledc_timer_config_t timer_conf = {
    .speed_mode       = LEDC_LOW_SPEED_MODE,
    .duty_resolution  = LEDC_TIMER_8_BIT,
    .timer_num        = (ledc_timer_t)timerNum,
    .freq_hz          = PWM_FREQ,
    .clk_cfg          = LEDC_AUTO_CLK
  };
  ledc_timer_config(&timer_conf);

  ledc_channel_config_t channel_conf = {
    .gpio_num   = pwmPin,
    .speed_mode = LEDC_LOW_SPEED_MODE,
    .channel    = (ledc_channel_t)pwmChannel,
    .intr_type  = LEDC_INTR_DISABLE,
    .timer_sel  = (ledc_timer_t)timerNum,
    .duty       = 0
  };
  ledc_channel_config(&channel_conf);
}

void driveMotorsDifferential(float pwmL, float pwmR) {
  digitalWrite(STBY, HIGH);

  int dutyL = constrain(abs(pwmL), 0, 255);
  int dutyR = constrain(abs(pwmR), 0, 255);

  // Motor Izquierdo
  if (pwmL > 0) {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
  } else {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, dutyL);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);

  // Motor Derecho
  if (pwmR > 0) {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
  } else {
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, dutyR);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);
}

// ==============================================================
// ========================= CONTROL CASCADA =====================
// ==============================================================

float cascada(float angle, float rpmL, float rpmR, float dt) {
  float error = setpoint_angle - angle;
  float derivative = (error - angle_prev_error) / dt;

  float pid_unsat = Kp_angle * error + Ki_angle * angle_integral + Kd_angle * derivative;

  float speed_ref = constrain(pid_unsat, -250, 250);

  if (!((pid_unsat != speed_ref) && (error * pid_unsat) > 0))
    angle_integral += error * dt;

  angle_prev_error = error;

  float speed_measured = (rpmL + rpmR) * 0.5f;
  float error_speed = speed_ref - speed_measured;

  float pwm_unsat = Kp_speed * error_speed + Ki_speed * speed_integral;
  float pwm_balanceo = constrain(pwm_unsat, -PWM_LIMIT, PWM_LIMIT);

  if (!((pwm_unsat != pwm_balanceo) && (error_speed * pwm_unsat) > 0))
    speed_integral += error_speed * dt;

  speed_integral = constrain(speed_integral, -150, 150);

  if (abs(angle) > MAX_ANGLE) return 0;

  return pwm_balanceo;
}

// ==============================================================
// ========================= TASK BALANCEO =======================
// ==============================================================

void TaskBalanceo(void *pvParameters) {
  const TickType_t period = pdMS_TO_TICKS(20);
  TickType_t lastWakeTime = xTaskGetTickCount();

  while (1) {
    vTaskDelayUntil(&lastWakeTime, period);

    long pR = countR; countR = 0;
    long pL = countL; countL = 0;

    float revolR = pR / PPR;
    float revolL = pL / PPR;

    float rpmR = (revolR / 0.02f) * 60.0f;
    float rpmL = (revolL / 0.02f) * 60.0f;

    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    float axf = ax - ax_offset;
    float ayf = ay - ay_offset;
    float azf = az - az_offset;
    float gyf = gx - gx_offset;

    float accelAngle = atan2(ayf, azf) * (180.0f / PI);
    float gyroAngle = angleFiltered + (gyf / 131.0f) * 0.02f;

    angleFiltered = 0.98f * gyroAngle + 0.02f * accelAngle;

    float pwm_base = cascada(angleFiltered, rpmL, rpmR, 0.02f);

    float pwmL = pwm_base * (1.0 + factor_giro);
    float pwmR = pwm_base * (1.0 - factor_giro);

    driveMotorsDifferential(pwmL, pwmR);
  }
}

// ==============================================================
// =========================== TASK LÍNEA ========================
// ==============================================================

void TaskLinea(void *pvParameters) {
  const TickType_t period = pdMS_TO_TICKS(100);
  TickType_t lastWakeTime = xTaskGetTickCount();

  while (1) {
    vTaskDelayUntil(&lastWakeTime, period);

    int suma = 0;
    long pos = 0;

    for (int i = 0; i < NUM_SENSORS; i++) {
      int val = !digitalRead(sensorPins[i]);
      pos += val * i * 100;
      suma += val;
    }

    if (suma > 0) {
      lineInput = pos / (double)suma;
      pidLinea.Compute();
      factor_giro = constrain(lineOutput, -0.6, 0.6);
    } else {
      factor_giro = 0;
    }
  }
}

// ==============================================================
// ======================== CALIBRACIÓN MPU ======================
// ==============================================================

void calibrateMPU() {
  const int samples = 1000;
  long ax_sum = 0, ay_sum = 0, az_sum = 0;
  long gx_sum = 0;

  for (int i = 0; i < samples; i++) {
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    ax_sum += ax;
    ay_sum += ay;
    az_sum += az;
    gx_sum += gx;

    delay(2);
  }

  ax_offset = ax_sum / samples;
  ay_offset = ay_sum / samples;
  az_offset = (az_sum / samples) - 16384;
  gx_offset = gx_sum / samples;

  angleFiltered = atan2(ay_offset, az_offset) * (180.0f / PI);
}

// ==============================================================
// =============================== SETUP =========================
// ==============================================================

void setup() {
  Serial.begin(115200);

  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT);

  setupMotorPWM(PWMA, CH_A, 0);
  setupMotorPWM(PWMB, CH_B, 1);

  pinMode(R_A, INPUT);
  pinMode(R_B, INPUT);
  pinMode(L_A, INPUT);
  pinMode(L_B, INPUT);

  attachInterrupt(R_A, isr_RA, CHANGE);
  attachInterrupt(L_A, isr_LA, CHANGE);

  for (int i = 0; i < NUM_SENSORS; i++)
    pinMode(sensorPins[i], INPUT);

  Wire.begin(42, 41);
  mpu.initialize();

  calibrateMPU();

  pidLinea.SetMode(AUTOMATIC);
  pidLinea.SetOutputLimits(-0.6, 0.6);

  xTaskCreatePinnedToCore(TaskBalanceo, "Balanceo", 10000, NULL, 3, NULL, 1);
  xTaskCreatePinnedToCore(TaskLinea,    "Linea",     4000,  NULL, 1, NULL, 0);
}

void loop() { }
=======
/*
  ================================================================
  =                  CascadaPrueba.ino (COMPLETO)               =
  =      Control de robot bípedo con balanceo + seguidor de     =
  =      línea en arquitectura de doble lazo (cascada).          =
  ================================================================

  Este código implementa:
  - Control de balanceo en cascada (PID de ángulo + PID velocidad)
  - Seguidor de línea con 8 sensores IR
  - Tareas FreeRTOS:
        * TaskBalanceo (Core 1, ~50 Hz)
        * TaskLinea    (Core 0, ~10 Hz)
  - Encoders en interrupción
  - Complementary filter para estimar ángulo a partir del MPU6050
  - PWM a 20 kHz con LEDC

  Toda la funcionalidad se encuentra completamente integrada.
*/

#include <Arduino.h>
#include <Wire.h>
#include <MPU6050.h>
#include <driver/ledc.h>
#include <PID_v1.h>

// ==============================================================
// ========================== PINES MOTORES ======================
// ==============================================================
#define AIN1 7
#define AIN2 6
#define PWMA 5
#define BIN1 16
#define BIN2 17
#define PWMB 18
#define STBY 15

// ==============================================================
// ============================== PWM ============================
// ==============================================================
#define PWM_FREQ 20000
#define PWM_RES 8

const ledc_channel_t CH_A = LEDC_CHANNEL_0;
const ledc_channel_t CH_B = LEDC_CHANNEL_1;

// ==============================================================
// ========================== ENCODERS ===========================
// ==============================================================
#define R_A 3
#define R_B 46
#define L_A 9
#define L_B 11

volatile long countR = 0;
volatile long countL = 0;

const float PPR = 44.0f * 119.0f;  // Pulses per revolution reales

// ==============================================================
// =========================== MPU6050 ===========================
// ==============================================================
MPU6050 mpu;

float ax_offset = 0, ay_offset = 0, az_offset = 0;
float gx_offset = 0;

float angleFiltered = 0;

// ==============================================================
// ===================== CONTROL EN CASCADA ======================
// ==============================================================

float setpoint_angle = 0.0;

// PID ÁNGULO
float Kp_angle = 80;
float Ki_angle = 0.9;
float Kd_angle = 1.8;

float angle_integral = 0;
float angle_prev_error = 0;

// PID VELOCIDAD
float Kp_speed = 0.7;
float Ki_speed = 0.0004;
float speed_integral = 0;

// Límites
float MAX_ANGLE = 40;
float PWM_LIMIT = 255;

// ==============================================================
// ===================== SEGUIDOR DE LÍNEA =======================
// ==============================================================

#define NUM_SENSORS 8
const uint8_t sensorPins[NUM_SENSORS] = {40, 38, 37, 36, 35, 0, 45, 48};

volatile float factor_giro = 0.0;

double lineInput = 0;
double lineOutput = 0;
double lineSetpoint = 350;

double Kp_line = 40;
double Ki_line = 0;
double Kd_line = 12;

PID pidLinea(&lineInput, &lineOutput, &lineSetpoint, Kp_line, Ki_line, Kd_line, DIRECT);

// ==============================================================
// ======================== ISRs ENCODERS ========================
// ==============================================================

void IRAM_ATTR isr_RA() {
  if (digitalRead(R_A) == digitalRead(R_B)) countR++;
  else countR--;
}

void IRAM_ATTR isr_LA() {
  if (digitalRead(L_A) == digitalRead(L_B)) countL++;
  else countL--;
}

// ==============================================================
// ======================== PWM MOTORES ==========================
// ==============================================================

void setupMotorPWM(int pwmPin, int pwmChannel, int timerNum) {
  ledc_timer_config_t timer_conf = {
    .speed_mode       = LEDC_LOW_SPEED_MODE,
    .duty_resolution  = LEDC_TIMER_8_BIT,
    .timer_num        = (ledc_timer_t)timerNum,
    .freq_hz          = PWM_FREQ,
    .clk_cfg          = LEDC_AUTO_CLK
  };
  ledc_timer_config(&timer_conf);

  ledc_channel_config_t channel_conf = {
    .gpio_num   = pwmPin,
    .speed_mode = LEDC_LOW_SPEED_MODE,
    .channel    = (ledc_channel_t)pwmChannel,
    .intr_type  = LEDC_INTR_DISABLE,
    .timer_sel  = (ledc_timer_t)timerNum,
    .duty       = 0
  };
  ledc_channel_config(&channel_conf);
}

void driveMotorsDifferential(float pwmL, float pwmR) {
  digitalWrite(STBY, HIGH);

  int dutyL = constrain(abs(pwmL), 0, 255);
  int dutyR = constrain(abs(pwmR), 0, 255);

  // Motor Izquierdo
  if (pwmL > 0) {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
  } else {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, dutyL);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);

  // Motor Derecho
  if (pwmR > 0) {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
  } else {
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, dutyR);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);
}

// ==============================================================
// ========================= CONTROL CASCADA =====================
// ==============================================================

float cascada(float angle, float rpmL, float rpmR, float dt) {
  float error = setpoint_angle - angle;
  float derivative = (error - angle_prev_error) / dt;

  float pid_unsat = Kp_angle * error + Ki_angle * angle_integral + Kd_angle * derivative;

  float speed_ref = constrain(pid_unsat, -250, 250);

  if (!((pid_unsat != speed_ref) && (error * pid_unsat) > 0))
    angle_integral += error * dt;

  angle_prev_error = error;

  float speed_measured = (rpmL + rpmR) * 0.5f;
  float error_speed = speed_ref - speed_measured;

  float pwm_unsat = Kp_speed * error_speed + Ki_speed * speed_integral;
  float pwm_balanceo = constrain(pwm_unsat, -PWM_LIMIT, PWM_LIMIT);

  if (!((pwm_unsat != pwm_balanceo) && (error_speed * pwm_unsat) > 0))
    speed_integral += error_speed * dt;

  speed_integral = constrain(speed_integral, -150, 150);

  if (abs(angle) > MAX_ANGLE) return 0;

  return pwm_balanceo;
}

// ==============================================================
// ========================= TASK BALANCEO =======================
// ==============================================================

void TaskBalanceo(void *pvParameters) {
  const TickType_t period = pdMS_TO_TICKS(20);
  TickType_t lastWakeTime = xTaskGetTickCount();

  while (1) {
    vTaskDelayUntil(&lastWakeTime, period);

    long pR = countR; countR = 0;
    long pL = countL; countL = 0;

    float revolR = pR / PPR;
    float revolL = pL / PPR;

    float rpmR = (revolR / 0.02f) * 60.0f;
    float rpmL = (revolL / 0.02f) * 60.0f;

    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    float axf = ax - ax_offset;
    float ayf = ay - ay_offset;
    float azf = az - az_offset;
    float gyf = gx - gx_offset;

    float accelAngle = atan2(ayf, azf) * (180.0f / PI);
    float gyroAngle = angleFiltered + (gyf / 131.0f) * 0.02f;

    angleFiltered = 0.98f * gyroAngle + 0.02f * accelAngle;

    float pwm_base = cascada(angleFiltered, rpmL, rpmR, 0.02f);

    float pwmL = pwm_base * (1.0 + factor_giro);
    float pwmR = pwm_base * (1.0 - factor_giro);

    driveMotorsDifferential(pwmL, pwmR);
  }
}

// ==============================================================
// =========================== TASK LÍNEA ========================
// ==============================================================

void TaskLinea(void *pvParameters) {
  const TickType_t period = pdMS_TO_TICKS(100);
  TickType_t lastWakeTime = xTaskGetTickCount();

  while (1) {
    vTaskDelayUntil(&lastWakeTime, period);

    int suma = 0;
    long pos = 0;

    for (int i = 0; i < NUM_SENSORS; i++) {
      int val = !digitalRead(sensorPins[i]);
      pos += val * i * 100;
      suma += val;
    }

    if (suma > 0) {
      lineInput = pos / (double)suma;
      pidLinea.Compute();
      factor_giro = constrain(lineOutput, -0.6, 0.6);
    } else {
      factor_giro = 0;
    }
  }
}

// ==============================================================
// ======================== CALIBRACIÓN MPU ======================
// ==============================================================

void calibrateMPU() {
  const int samples = 1000;
  long ax_sum = 0, ay_sum = 0, az_sum = 0;
  long gx_sum = 0;

  for (int i = 0; i < samples; i++) {
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    ax_sum += ax;
    ay_sum += ay;
    az_sum += az;
    gx_sum += gx;

    delay(2);
  }

  ax_offset = ax_sum / samples;
  ay_offset = ay_sum / samples;
  az_offset = (az_sum / samples) - 16384;
  gx_offset = gx_sum / samples;

  angleFiltered = atan2(ay_offset, az_offset) * (180.0f / PI);
}

// ==============================================================
// =============================== SETUP =========================
// ==============================================================

void setup() {
  Serial.begin(115200);

  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT);

  setupMotorPWM(PWMA, CH_A, 0);
  setupMotorPWM(PWMB, CH_B, 1);

  pinMode(R_A, INPUT);
  pinMode(R_B, INPUT);
  pinMode(L_A, INPUT);
  pinMode(L_B, INPUT);

  attachInterrupt(R_A, isr_RA, CHANGE);
  attachInterrupt(L_A, isr_LA, CHANGE);

  for (int i = 0; i < NUM_SENSORS; i++)
    pinMode(sensorPins[i], INPUT);

  Wire.begin(42, 41);
  mpu.initialize();

  calibrateMPU();

  pidLinea.SetMode(AUTOMATIC);
  pidLinea.SetOutputLimits(-0.6, 0.6);

  xTaskCreatePinnedToCore(TaskBalanceo, "Balanceo", 10000, NULL, 3, NULL, 1);
  xTaskCreatePinnedToCore(TaskLinea,    "Linea",     4000,  NULL, 1, NULL, 0);
}

void loop() { }
>>>>>>> ec42d93 (Inicial all)
