<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> e23c40d (New Version)
#include <Arduino.h>
#include "Neural_Networks_FF.h"
#include <Wire.h>
#include <MPU6050.h>
#include <driver/ledc.h>
#include <Preferences.h>

// ================= BOTÓN ===============
#define BTN_CAL 10
Preferences prefs;
bool calibratedOnce = false;

// Handles para poder suspender/reanudar tareas
TaskHandle_t taskBalHandle = NULL;
TaskHandle_t taskLineHandle = NULL;

// ===================== PINES MOTORES ==========================
#define AIN1 7
#define AIN2 6
#define PWMA 5
#define BIN1 16
#define BIN2 17
#define PWMB 18
#define STBY 15

// Contructor de la red neuronal
Neural_Networks_FF net = Neural_Networks_FF();
// Array dinamico para ingresar las entradas a la red
Dynamic_Array XI = Dynamic_Array();
// Array dinamico para ingresar las salidas deseadas
Dynamic_Array D = Dynamic_Array();
// Array dinamico tipo string para ingresar las funciones de activacion por capa
Dynamic_Array FAC_STR = Dynamic_Array();
// Array dinamico para ingresar la estructura de la red como vector
Dynamic_Array EST = Dynamic_Array();
Dynamic_Array posicion = Dynamic_Array();

// ===================== PWM ====================================
#define PWM_FREQ 20000
#define PWM_RES 8
const ledc_channel_t CH_A = LEDC_CHANNEL_0; // Motor Izquierdo (A)
const ledc_channel_t CH_B = LEDC_CHANNEL_1; // Motor Derecho (B)

// ===================== PINES ENCODERS ==========================
#define R_A 3
#define R_B 46
#define L_A 9
#define L_B 11

volatile long countR = 0;
volatile long countL = 0;

const int CPR = 44;
// =====================  Variables para el control RN ==========================

float posRN = 0.00;
float errorMPU = 0.00;
float error_1MPU = 0.00;
float error_2MPU = 0.00;
float errorQTR = 0.00;
float error_1QTR = 0.00;
float error_2QTR = 0.00;

float setPointMPU = 0.000;
float setPointQTR = 0.000;
float Output = 0.00;

// ===================== MPU ====================================
MPU6050 mpu;
float ax_offset = 0, ay_offset = 0, az_offset = 0;
float gx_offset = 0;

// ===================== FILTRO =================================
float angleFiltered = 0;

// ===================== CONTROL EN CASCADA (BALANCEO) ======================
float Kp_angle = 85;  // 80
float Ki_angle = 0.8; // 1
float Kd_angle = 1.6; // Pruebalo 1

float angle_integral = 0;
float angle_prev_error = 0;

float Kp_speed = 0.8; // 0.8
float Ki_speed = 0.001;
float speed_integral = 0;

float MAX_ANGLE = 40;
float PWM_LIMIT = 255;

// ===================== SEGUIDOR DE LÍNEA ======================
#define NUM_SENSORS 8
// const uint8_t sensorPins[NUM_SENSORS] = { 40, 38, 37, 36, 35, 0, 45, 48 };
const uint8_t sensorPins[NUM_SENSORS] = {48, 45, 0, 35, 36, 37, 38, 40};
int sensorValues[NUM_SENSORS];
float pos = 0.0;
float cont = 0.0;
// La salida del PID de línea.
// Valor de 0.0 es centro. +/- 0.25 es el giro máximo permitido.
volatile float factor_giro = 0.0;

// PID Línea
double lineInput = 0;
double lineOutput = 0;

double Kp_line = 30;
double Ki_line = 0.001;
double Kd_line = 10;


// ===================== ISRs ENCODER ============================
void IRAM_ATTR isr_RA()
{
  if (digitalRead(R_A) == digitalRead(R_B))
    countR++;
  else
    countR--;
}

void IRAM_ATTR isr_LA()
{
  if (digitalRead(L_A) == digitalRead(L_B))
    countL++;
  else
    countL--;
}

// ===================== PWM MOTOR ===============================
void setupMotorPWM(int pwmPin, int pwmChannel, int timerNum)
{
  ledc_timer_config_t timer_conf = {
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .duty_resolution = LEDC_TIMER_8_BIT,
      .timer_num = (ledc_timer_t)timerNum,
      .freq_hz = PWM_FREQ,
      .clk_cfg = LEDC_AUTO_CLK};

  ledc_timer_config(&timer_conf);

  ledc_channel_config_t channel_conf = {
      .gpio_num = pwmPin,
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .channel = (ledc_channel_t)pwmChannel,
      .intr_type = LEDC_INTR_DISABLE,
      .timer_sel = (ledc_timer_t)timerNum,
      .duty = 0};

  ledc_channel_config(&channel_conf);
}

/**
 * @brief Aplica PWMs diferenciales a los dos motores.
 * @param pwmL PWM para el motor izquierdo (CH_A)
 * @param pwmR PWM para el motor derecho (CH_B)
 */
void driveMotorsDifferential(float pwmL, float pwmR)
{
  digitalWrite(STBY, HIGH);

  // --- MOTOR IZQUIERDO (CH_A) ---
  int dutyL = constrain(abs(pwmL), 0, 255);

  // Lógica de dirección: Asumimos que HIGH/LOW para AIN2/AIN1 es adelante
  if (pwmL > 0)
  { // Adelante
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
  }
  else
  { // Atrás
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, dutyL);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);

  //--- MOTOR DERECHO (CH_B) ---
  int dutyR = constrain(abs(pwmR), 0, 255);

  // Lógica de dirección: Asumimos que HIGH/LOW para BIN2/BIN1 es adelante
  if (pwmR > 0)
  { // Adelante
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
  }
  else
  { // Atrás
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, dutyR);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);
}

// ===================== CONTROL EN CASCADA ======================
float cascada(float angle, float rpmLeft, float rpmRight, float dt)
{
  posicion.WriteArray_2D(0, 0, angle / 100.00);
  errorMPU = setPointMPU - angle;
    float derivative = (errorMPU - angle_prev_error) / dt;

  XI.WriteArray_2D(0, 0, errorMPU);
  XI.WriteArray_2D(0, 1, errorMPU - error_1MPU);
  XI.WriteArray_2D(0, 2, error_1MPU - error_2MPU);
  // net.DATA_CENTERING(XI);
  net.NORMALIZE_DATA(XI, 100.00);
  D.WriteArray_2D(0, 0, setPointMPU / 100.00);
  net.TRAIN_NET_ONLINE(XI, D, posicion);
  Output = net.y.ReadArray_2D(net.y.GetRows() - 1, 0);
  error_2MPU = error_1MPU;
  error_1MPU = errorMPU;
  Kp_angle = abs(Output * 100.00);

  float pid_unsat = Kp_angle * errorMPU + Ki_angle * angle_integral + Kd_angle * derivative;

  // Lazo interno: Salida es la REFERENCIA DE VELOCIDAD
  float speed_ref = constrain(pid_unsat, -300, 300);
  if (!((pid_unsat != speed_ref) && (errorMPU * pid_unsat) > 0))
  {
    angle_integral += errorMPU * dt;
  }
  angle_prev_error = errorMPU;
  // Lazo externo: PID de Velocidad
  float speed_measured = (rpmLeft + rpmRight) * 0.5;
  float error_speed = speed_ref - speed_measured;

  // Salida es el PWM BASE que se necesita para mantener la velocidad
  float pwm_unsat = Kp_speed * error_speed + Ki_speed * speed_integral;
  float pwm_balanceo_base = constrain(pwm_unsat, -PWM_LIMIT, PWM_LIMIT);

  if (!((pwm_unsat != pwm_balanceo_base) && (error_speed * pwm_unsat) > 0))
  {
    speed_integral += error_speed * dt;
  }

  speed_integral = constrain(speed_integral, -150, 150);

  if (abs(angle) > MAX_ANGLE)
    return 0;
  return pwm_balanceo_base;
}

void saveCalibration()
{
  prefs.begin("mpu", false);
  prefs.putFloat("ax_off", ax_offset);
  prefs.putFloat("ay_off", ay_offset);
  prefs.putFloat("az_off", az_offset);
  prefs.putFloat("gx_off", gx_offset);
  prefs.end();
  Serial.println(">> Calibración guardada.");
}

bool loadCalibration()
{
  prefs.begin("mpu", true);
  if (!prefs.isKey("ax_off"))
  {
    prefs.end();
    return false;
  }
  ax_offset = prefs.getFloat("ax_off");
  ay_offset = prefs.getFloat("ay_off");
  az_offset = prefs.getFloat("az_off");
  gx_offset = prefs.getFloat("gx_off");
  prefs.end();
  return true;
}

void calibrateMPU()
{
  Serial.println(">> Iniciando calibración MPU...");

  long ax_sum = 0, ay_sum = 0, az_sum = 0, gx_sum = 0;
  const int samples = 500;

  for (int i = 0; i < samples; i++)
  {
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    ax_sum += ax;
    ay_sum += ay;
    az_sum += az;
    gx_sum += gx;
    delay(3);
  }

  ax_offset = ax_sum / samples;
  ay_offset = ay_sum / samples;
  az_offset = (az_sum / samples) - 16384;
  gx_offset = gx_sum / samples;

  saveCalibration();
  Serial.println(">> Calibración MPU COMPLETA.");
}

// ===================== TASK BALANCEO ===========================
void TaskBalanceo(void *pvParameters)
{
  const TickType_t dt_task = pdMS_TO_TICKS(10); // 10 ms

  while (true)
  {
    // La MPU, el filtro y el cálculo de RPM quedan IGUAL
    // ... (Código MPU/Filtro/RPM) ...
    cont = cont + 1;
    float dt = 0.020;
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    float accelY = (ay - ay_offset) / 16384.0;
    float accelZ = (az - az_offset) / 16384.0;
    float gyroX = (gx - gx_offset) / 131.0;
    float angleAcc = atan2(accelY, accelZ) * 180.0 / PI;
    angleFiltered = 0.98 * (angleFiltered + gyroX * dt) + 0.02 * angleAcc;

    long pulsesR = countR;
    long pulsesL = countL;
    countR = 0;
    countL = 0;

    const float PPR = 44.0 * 119.0;
    float revR = pulsesR / PPR;
    float revL = pulsesL / PPR;
    float rpmR = (revR / dt) * 60.0;
    float rpmL = (revL / dt) * 60.0;

    static float rpmR_f = 0, rpmL_f = 0;
    rpmR_f = 0.7 * rpmR_f + 0.3 * rpmR;
    rpmL_f = 0.7 * rpmL_f + 0.3 * rpmL;
    if ( cont < 2000)
    {
      setPointMPU = 0.7;
    }
    if (cont > 10000)
    {
      setPointMPU = 0.0;
    }
    if (cont > 10000)
    {
      cont = 0.0;
    }
    // ---- CONTROL DE BALANCEO: Obtiene el PWM BASE ----
    float pwm_balanceo_base = cascada(angleFiltered, rpmL_f, rpmR_f, dt);

    // ---- FUSIÓN MULTIPLICATIVA DE LA LÍNEA ----
    // La magnitud del factor_giro (ej. 0.25) determina el giro máximo.
    // Si factor_giro > 0, necesita girar a la izquierda (Aumentar L, reducir R).
    // Si factor_giro < 0, necesita girar a la derecha (Reducir L, aumentar R).

    float factorL = 1.0 + factor_giro;
    float factorR = 1.0 - factor_giro;

    float pwm_finalL = pwm_balanceo_base * factorL;
    float pwm_finalR = pwm_balanceo_base * factorR;

    // Recortar al límite absoluto de PWM_LIMIT (255)
    pwm_finalL = constrain(pwm_finalL, -PWM_LIMIT, PWM_LIMIT);
    pwm_finalR = constrain(pwm_finalR, -PWM_LIMIT, PWM_LIMIT);

    // ---- ACTUACIÓN ----
    driveMotorsDifferential(pwm_finalL, pwm_finalR);

    // Debug
    Serial.print("Ang: ");
    Serial.print(angleFiltered);
    Serial.print(" | errorMPU: ");
    Serial.print(errorMPU);
    Serial.print(" | Pos: ");
    Serial.print(pos);
    Serial.print(" | errorPOS: ");
    Serial.print(errorQTR);
    Serial.print(" | PWM Base: ");
    Serial.print(pwm_balanceo_base);    
    Serial.print(" | PWM L: ");
    Serial.print(pwm_finalL);
    Serial.print(" | PWM R: ");
    Serial.println(pwm_finalR);

    vTaskDelay(dt_task);
  }
}


void readQTR() {
    for (int i = 0; i < NUM_SENSORS; i++) {
        sensorValues[i] = digitalRead(sensorPins[i]);  
        // 0 = línea negra
        // 1 = fondo blanco
    }
}

int positions[NUM_SENSORS] = {-350, -250, -150, -50, 50, 150, 250, 350};

int getLinePosition() {
    long weightedSum = 0;
    long sum = 0;

    for (int i = 0; i < NUM_SENSORS; i++) {
        int value = (sensorValues[i] == 0) ? 1 : 0;  
        // Convertimos: 1 = línea detectada, 0 = fondo

        weightedSum += (long)value * positions[i];
        sum        += value;
    }

    if (sum == 0) {
        // No encontró línea
        return 0;
    }

    return weightedSum / sum;  // Centro promedio
}


// ===================== TASK LÍNEA ==============================
void TaskLinea(void *pvParameters)
{
  const TickType_t period = pdMS_TO_TICKS(100); // 10 Hz
  TickType_t lastWake = xTaskGetTickCount();

//   Sensor:      0   1   2   3   4   5   6   7
// Posición:  -350 -250 -150 -50 +50 +150 +250 +350

  while (true)
  {
    readQTR();
    pos = getLinePosition();
    errorQTR = setPointQTR - pos;
    error_2QTR = error_1QTR;
    error_1QTR = errorQTR;
    vTaskDelayUntil(&lastWake, period);
  }
}

// Detiene físicamente los motores y suspende las tareas relevantes
void stopRobotAndTasks()
{
  // Apagar PWM (poner duty 0)
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, 0);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, 0);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);

  // Opcional: desactivar STBY si tu driver lo soporta (evita que se energicen los H-bridges)
  digitalWrite(STBY, LOW);

  // Suspender sólo las tareas que usamos
  if (taskBalHandle != NULL)
    vTaskSuspend(taskBalHandle);
  if (taskLineHandle != NULL)
    vTaskSuspend(taskLineHandle);

  // Pequeña espera para asegurar que tareas se suspendan
  delay(20);
}

// Reactiva tareas y vuelve a permitir movimiento
void resumeRobotAndTasks()
{
  // Reactivar tareas primero (para que arranquen sus loops)
  if (taskLineHandle != NULL)
    vTaskResume(taskLineHandle);
  if (taskBalHandle != NULL)
    vTaskResume(taskBalHandle);

  // Rehabilitar STBY para permitir motores
  digitalWrite(STBY, HIGH);

  // Espera para que las tareas estabilicen antes de permitir movimiento
  delay(20);
}

// ===================== SETUP ===================================
void setup()
{
  Serial.begin(115200);
  Wire.begin(41, 42);
  mpu.initialize();

  pinMode(BTN_CAL, INPUT_PULLUP); // Botón hacia GND

  // ======== CARGAR CALIBRACIÓN GUARDADA =========
  if (loadCalibration())
  {
    Serial.println(">> Calibración cargada de memoria.");
  }
  else
  {
    Serial.println(">> No existe calibración guardada. Necesitas presionar el botón.");
  }

  // ======== Inicializar Motores y Encoders ========
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);

  setupMotorPWM(PWMA, CH_A, 0);
  setupMotorPWM(PWMB, CH_B, 1);

  pinMode(R_A, INPUT_PULLUP);
  pinMode(R_B, INPUT_PULLUP);
  pinMode(L_A, INPUT_PULLUP);
  pinMode(L_B, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(R_A), isr_RA, CHANGE);
  attachInterrupt(digitalPinToInterrupt(L_A), isr_LA, CHANGE);
  // CONFIGURACION DE LA RED NEURONAL
  // Crear e inicializar el array de los datos de entrada
  XI.NewArray_2D(1, 3);
  XI.ToinitializeArray_2D(0.0);
  // Crear e inicializar el array de salidas deseadas
  D.NewArray_2D(1, 1);
  D.ToinitializeArray_2D(0.0);
  // Columnas de XI
  byte XC = XI.GetColumns();
  // Filas de D
  byte DF = D.GetRows();
  // Filas de XI
  byte XF = XI.GetRows();
  // Definomos numero de capas
  byte L = 3;
  // Creamos e inicializamos el array donde se guardara
  // la estructura de la red
  EST.NewArray_2D(1, L);
  EST.ToinitializeArray_2D(0.0);
  float NC = EST.GetColumns();
  // Vector que contiene la estructura de la red
  float V[] = {XC, 3, DF};
  // Copiamos el vector al array
  for (byte i = 0; i < NC; i++)
  {
    EST.WriteArray_2D(0, i, V[i]);
  }
  // creamos array tipo string para pasar
  // las funciones de activacion
  FAC_STR.CharNewArray_1D(L);
  // Vector que contine las funciones de activacion
  char *myStrings[] = {"logsig", "logsig", "poslin_lim"};
  // Copiamos el vector al array
  for (byte i = 0; i < FAC_STR.GetRows(); i++)
  {
    FAC_STR.CharWriteArray_1D(i, myStrings[i]);
  }
  net.dposlin_limits(1, -1);
  // Creamos la red
  net.LearningRate = 0.00;
  net.FEED_FORWARD_NET(EST, FAC_STR);
  posicion.NewArray_2D(1, 1);
  posicion.ToinitializeArray_2D(0.0);
  // Variable de entrenamiento
  net.LearningRate = 0.025; // 0.025;
  setPointMPU = 0.400;
  // Sensores de línea
  for (int i = 0; i < NUM_SENSORS; i++)
    pinMode(sensorPins[i], INPUT);

  // Si ya existe calibración → calcula ángulo inicial
  if (loadCalibration())
  {
    int16_t ax_init, ay_init, az_init;
    mpu.getAcceleration(&ax_init, &ay_init, &az_init);
    angleFiltered = atan2(
                        (ay_init - ay_offset) / 16384.0,
                        (az_init - az_offset) / 16384.0) *
                    180.0 / PI;
  }

  // ======== CREAR TAREAS ========
  xTaskCreatePinnedToCore(TaskBalanceo, "TaskBalanceo", 10000, NULL, 3, &taskBalHandle, 1);
  xTaskCreatePinnedToCore(TaskLinea, "TaskLinea", 4000, NULL, 1, &taskLineHandle, 0);

  Serial.println("Robot listo. Presiona el botón para calibrar la MPU.");
}

void loop()
{
  // Detecta si el botón está presionado (pin 10 a GND)
  if (digitalRead(BTN_CAL) == LOW)
  {
    Serial.println(">> Botón presionado. Deteniendo robot para calibrar...");

    stopRobotAndTasks(); // apaga motores + suspende tareas
    delay(50);           // pequeño debounce / asegurar suspensión

    Serial.println(">> Iniciando calibración MPU...");
    calibrateMPU(); // hace la calibración (usa delay internamente)
    Serial.println(">> Calibración MPU completa y guardada.");

    delay(50);

    resumeRobotAndTasks(); // reactiva tareas y motores
    Serial.println(">> Robot reanudado.");

     vTaskDelay(pdMS_TO_TICKS(10)); // 10 ms
  }
<<<<<<< HEAD
=======
#include <Arduino.h>
#include "Neural_Networks_FF.h"
#include <Wire.h>
#include <MPU6050.h>
#include <driver/ledc.h>
#include <Preferences.h>

// ================= BOTÓN ===============
#define BTN_CAL 10
Preferences prefs;
bool calibratedOnce = false;

// Handles para poder suspender/reanudar tareas
TaskHandle_t taskBalHandle = NULL;
TaskHandle_t taskLineHandle = NULL;

// ===================== PINES MOTORES ==========================
#define AIN1 7
#define AIN2 6
#define PWMA 5
#define BIN1 16
#define BIN2 17
#define PWMB 18
#define STBY 15

// Contructor de la red neuronal
Neural_Networks_FF net = Neural_Networks_FF();
// Array dinamico para ingresar las entradas a la red
Dynamic_Array XI = Dynamic_Array();
// Array dinamico para ingresar las salidas deseadas
Dynamic_Array D = Dynamic_Array();
// Array dinamico tipo string para ingresar las funciones de activacion por capa
Dynamic_Array FAC_STR = Dynamic_Array();
// Array dinamico para ingresar la estructura de la red como vector
Dynamic_Array EST = Dynamic_Array();
Dynamic_Array posicion = Dynamic_Array();

// ===================== PWM ====================================
#define PWM_FREQ 20000
#define PWM_RES 8
const ledc_channel_t CH_A = LEDC_CHANNEL_0; // Motor Izquierdo (A)
const ledc_channel_t CH_B = LEDC_CHANNEL_1; // Motor Derecho (B)

// ===================== PINES ENCODERS ==========================
#define R_A 3
#define R_B 46
#define L_A 9
#define L_B 11

volatile long countR = 0;
volatile long countL = 0;

const int CPR = 44;
// =====================  Variables para el control RN ==========================

float posRN = 0.00;
float errorMPU = 0.00;
float error_1MPU = 0.00;
float error_2MPU = 0.00;
float errorQTR = 0.00;
float error_1QTR = 0.00;
float error_2QTR = 0.00;

float setPointMPU = 0.000;
float setPointQTR = 0.000;
float Output = 0.00;

// ===================== MPU ====================================
MPU6050 mpu;
float ax_offset = 0, ay_offset = 0, az_offset = 0;
float gx_offset = 0;

// ===================== FILTRO =================================
float angleFiltered = 0;

// ===================== CONTROL EN CASCADA (BALANCEO) ======================
float Kp_angle = 85;  // 80
float Ki_angle = 0.8; // 1
float Kd_angle = 1.6; // Pruebalo 1

float angle_integral = 0;
float angle_prev_error = 0;

float Kp_speed = 0.8; // 0.8
float Ki_speed = 0.001;
float speed_integral = 0;

float MAX_ANGLE = 40;
float PWM_LIMIT = 255;

// ===================== SEGUIDOR DE LÍNEA ======================
#define NUM_SENSORS 8
// const uint8_t sensorPins[NUM_SENSORS] = { 40, 38, 37, 36, 35, 0, 45, 48 };
const uint8_t sensorPins[NUM_SENSORS] = {48, 45, 0, 35, 36, 37, 38, 40};
int sensorValues[NUM_SENSORS];
float pos = 0.0;
float cont = 0.0;
// La salida del PID de línea.
// Valor de 0.0 es centro. +/- 0.25 es el giro máximo permitido.
volatile float factor_giro = 0.0;

// PID Línea
double lineInput = 0;
double lineOutput = 0;

double Kp_line = 30;
double Ki_line = 0.001;
double Kd_line = 10;


// ===================== ISRs ENCODER ============================
void IRAM_ATTR isr_RA()
{
  if (digitalRead(R_A) == digitalRead(R_B))
    countR++;
  else
    countR--;
}

void IRAM_ATTR isr_LA()
{
  if (digitalRead(L_A) == digitalRead(L_B))
    countL++;
  else
    countL--;
}

// ===================== PWM MOTOR ===============================
void setupMotorPWM(int pwmPin, int pwmChannel, int timerNum)
{
  ledc_timer_config_t timer_conf = {
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .duty_resolution = LEDC_TIMER_8_BIT,
      .timer_num = (ledc_timer_t)timerNum,
      .freq_hz = PWM_FREQ,
      .clk_cfg = LEDC_AUTO_CLK};

  ledc_timer_config(&timer_conf);

  ledc_channel_config_t channel_conf = {
      .gpio_num = pwmPin,
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .channel = (ledc_channel_t)pwmChannel,
      .intr_type = LEDC_INTR_DISABLE,
      .timer_sel = (ledc_timer_t)timerNum,
      .duty = 0};

  ledc_channel_config(&channel_conf);
}

/**
 * @brief Aplica PWMs diferenciales a los dos motores.
 * @param pwmL PWM para el motor izquierdo (CH_A)
 * @param pwmR PWM para el motor derecho (CH_B)
 */
void driveMotorsDifferential(float pwmL, float pwmR)
{
  digitalWrite(STBY, HIGH);

  // --- MOTOR IZQUIERDO (CH_A) ---
  int dutyL = constrain(abs(pwmL), 0, 255);

  // Lógica de dirección: Asumimos que HIGH/LOW para AIN2/AIN1 es adelante
  if (pwmL > 0)
  { // Adelante
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
  }
  else
  { // Atrás
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, dutyL);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);

  //--- MOTOR DERECHO (CH_B) ---
  int dutyR = constrain(abs(pwmR), 0, 255);

  // Lógica de dirección: Asumimos que HIGH/LOW para BIN2/BIN1 es adelante
  if (pwmR > 0)
  { // Adelante
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
  }
  else
  { // Atrás
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, dutyR);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);
}

// ===================== CONTROL EN CASCADA ======================
float cascada(float angle, float rpmLeft, float rpmRight, float dt)
{
  posicion.WriteArray_2D(0, 0, angle / 100.00);
  errorMPU = setPointMPU - angle;
    float derivative = (errorMPU - angle_prev_error) / dt;

  XI.WriteArray_2D(0, 0, errorMPU);
  XI.WriteArray_2D(0, 1, errorMPU - error_1MPU);
  XI.WriteArray_2D(0, 2, error_1MPU - error_2MPU);
  // net.DATA_CENTERING(XI);
  net.NORMALIZE_DATA(XI, 100.00);
  D.WriteArray_2D(0, 0, setPointMPU / 100.00);
  net.TRAIN_NET_ONLINE(XI, D, posicion);
  Output = net.y.ReadArray_2D(net.y.GetRows() - 1, 0);
  error_2MPU = error_1MPU;
  error_1MPU = errorMPU;
  Kp_angle = abs(Output * 100.00);

  float pid_unsat = Kp_angle * errorMPU + Ki_angle * angle_integral + Kd_angle * derivative;

  // Lazo interno: Salida es la REFERENCIA DE VELOCIDAD
  float speed_ref = constrain(pid_unsat, -300, 300);
  if (!((pid_unsat != speed_ref) && (errorMPU * pid_unsat) > 0))
  {
    angle_integral += errorMPU * dt;
  }
  angle_prev_error = errorMPU;
  // Lazo externo: PID de Velocidad
  float speed_measured = (rpmLeft + rpmRight) * 0.5;
  float error_speed = speed_ref - speed_measured;

  // Salida es el PWM BASE que se necesita para mantener la velocidad
  float pwm_unsat = Kp_speed * error_speed + Ki_speed * speed_integral;
  float pwm_balanceo_base = constrain(pwm_unsat, -PWM_LIMIT, PWM_LIMIT);

  if (!((pwm_unsat != pwm_balanceo_base) && (error_speed * pwm_unsat) > 0))
  {
    speed_integral += error_speed * dt;
  }

  speed_integral = constrain(speed_integral, -150, 150);

  if (abs(angle) > MAX_ANGLE)
    return 0;
  return pwm_balanceo_base;
}

void saveCalibration()
{
  prefs.begin("mpu", false);
  prefs.putFloat("ax_off", ax_offset);
  prefs.putFloat("ay_off", ay_offset);
  prefs.putFloat("az_off", az_offset);
  prefs.putFloat("gx_off", gx_offset);
  prefs.end();
  Serial.println(">> Calibración guardada.");
}

bool loadCalibration()
{
  prefs.begin("mpu", true);
  if (!prefs.isKey("ax_off"))
  {
    prefs.end();
    return false;
  }
  ax_offset = prefs.getFloat("ax_off");
  ay_offset = prefs.getFloat("ay_off");
  az_offset = prefs.getFloat("az_off");
  gx_offset = prefs.getFloat("gx_off");
  prefs.end();
  return true;
}

void calibrateMPU()
{
  Serial.println(">> Iniciando calibración MPU...");

  long ax_sum = 0, ay_sum = 0, az_sum = 0, gx_sum = 0;
  const int samples = 500;

  for (int i = 0; i < samples; i++)
  {
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    ax_sum += ax;
    ay_sum += ay;
    az_sum += az;
    gx_sum += gx;
    delay(3);
  }

  ax_offset = ax_sum / samples;
  ay_offset = ay_sum / samples;
  az_offset = (az_sum / samples) - 16384;
  gx_offset = gx_sum / samples;

  saveCalibration();
  Serial.println(">> Calibración MPU COMPLETA.");
}

// ===================== TASK BALANCEO ===========================
void TaskBalanceo(void *pvParameters)
{
  const TickType_t dt_task = pdMS_TO_TICKS(10); // 10 ms

  while (true)
  {
    // La MPU, el filtro y el cálculo de RPM quedan IGUAL
    // ... (Código MPU/Filtro/RPM) ...
    cont = cont + 1;
    float dt = 0.020;
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    float accelY = (ay - ay_offset) / 16384.0;
    float accelZ = (az - az_offset) / 16384.0;
    float gyroX = (gx - gx_offset) / 131.0;
    float angleAcc = atan2(accelY, accelZ) * 180.0 / PI;
    angleFiltered = 0.98 * (angleFiltered + gyroX * dt) + 0.02 * angleAcc;

    long pulsesR = countR;
    long pulsesL = countL;
    countR = 0;
    countL = 0;

    const float PPR = 44.0 * 119.0;
    float revR = pulsesR / PPR;
    float revL = pulsesL / PPR;
    float rpmR = (revR / dt) * 60.0;
    float rpmL = (revL / dt) * 60.0;

    static float rpmR_f = 0, rpmL_f = 0;
    rpmR_f = 0.7 * rpmR_f + 0.3 * rpmR;
    rpmL_f = 0.7 * rpmL_f + 0.3 * rpmL;
    if ( cont < 2000)
    {
      setPointMPU = 0.7;
    }
    if (cont > 10000)
    {
      setPointMPU = 0.0;
    }
    if (cont > 10000)
    {
      cont = 0.0;
    }
    // ---- CONTROL DE BALANCEO: Obtiene el PWM BASE ----
    float pwm_balanceo_base = cascada(angleFiltered, rpmL_f, rpmR_f, dt);

    // ---- FUSIÓN MULTIPLICATIVA DE LA LÍNEA ----
    // La magnitud del factor_giro (ej. 0.25) determina el giro máximo.
    // Si factor_giro > 0, necesita girar a la izquierda (Aumentar L, reducir R).
    // Si factor_giro < 0, necesita girar a la derecha (Reducir L, aumentar R).

    float factorL = 1.0 + factor_giro;
    float factorR = 1.0 - factor_giro;

    float pwm_finalL = pwm_balanceo_base * factorL;
    float pwm_finalR = pwm_balanceo_base * factorR;

    // Recortar al límite absoluto de PWM_LIMIT (255)
    pwm_finalL = constrain(pwm_finalL, -PWM_LIMIT, PWM_LIMIT);
    pwm_finalR = constrain(pwm_finalR, -PWM_LIMIT, PWM_LIMIT);

    // ---- ACTUACIÓN ----
    driveMotorsDifferential(pwm_finalL, pwm_finalR);

    // Debug
    Serial.print("Ang: ");
    Serial.print(angleFiltered);
    Serial.print(" | errorMPU: ");
    Serial.print(errorMPU);
    Serial.print(" | Pos: ");
    Serial.print(pos);
    Serial.print(" | errorPOS: ");
    Serial.print(errorQTR);
    Serial.print(" | PWM Base: ");
    Serial.print(pwm_balanceo_base);    
    Serial.print(" | PWM L: ");
    Serial.print(pwm_finalL);
    Serial.print(" | PWM R: ");
    Serial.println(pwm_finalR);

    vTaskDelay(dt_task);
  }
}


void readQTR() {
    for (int i = 0; i < NUM_SENSORS; i++) {
        sensorValues[i] = digitalRead(sensorPins[i]);  
        // 0 = línea negra
        // 1 = fondo blanco
    }
}

int positions[NUM_SENSORS] = {-350, -250, -150, -50, 50, 150, 250, 350};

int getLinePosition() {
    long weightedSum = 0;
    long sum = 0;

    for (int i = 0; i < NUM_SENSORS; i++) {
        int value = (sensorValues[i] == 0) ? 1 : 0;  
        // Convertimos: 1 = línea detectada, 0 = fondo

        weightedSum += (long)value * positions[i];
        sum        += value;
    }

    if (sum == 0) {
        // No encontró línea
        return 0;
    }

    return weightedSum / sum;  // Centro promedio
}


// ===================== TASK LÍNEA ==============================
void TaskLinea(void *pvParameters)
{
  const TickType_t period = pdMS_TO_TICKS(100); // 10 Hz
  TickType_t lastWake = xTaskGetTickCount();

//   Sensor:      0   1   2   3   4   5   6   7
// Posición:  -350 -250 -150 -50 +50 +150 +250 +350

  while (true)
  {
    readQTR();
    pos = getLinePosition();
    errorQTR = setPointQTR - pos;
    error_2QTR = error_1QTR;
    error_1QTR = errorQTR;
    vTaskDelayUntil(&lastWake, period);
  }
}

// Detiene físicamente los motores y suspende las tareas relevantes
void stopRobotAndTasks()
{
  // Apagar PWM (poner duty 0)
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, 0);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, 0);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);

  // Opcional: desactivar STBY si tu driver lo soporta (evita que se energicen los H-bridges)
  digitalWrite(STBY, LOW);

  // Suspender sólo las tareas que usamos
  if (taskBalHandle != NULL)
    vTaskSuspend(taskBalHandle);
  if (taskLineHandle != NULL)
    vTaskSuspend(taskLineHandle);

  // Pequeña espera para asegurar que tareas se suspendan
  delay(20);
}

// Reactiva tareas y vuelve a permitir movimiento
void resumeRobotAndTasks()
{
  // Reactivar tareas primero (para que arranquen sus loops)
  if (taskLineHandle != NULL)
    vTaskResume(taskLineHandle);
  if (taskBalHandle != NULL)
    vTaskResume(taskBalHandle);

  // Rehabilitar STBY para permitir motores
  digitalWrite(STBY, HIGH);

  // Espera para que las tareas estabilicen antes de permitir movimiento
  delay(20);
}

// ===================== SETUP ===================================
void setup()
{
  Serial.begin(115200);
  Wire.begin(41, 42);
  mpu.initialize();

  pinMode(BTN_CAL, INPUT_PULLUP); // Botón hacia GND

  // ======== CARGAR CALIBRACIÓN GUARDADA =========
  if (loadCalibration())
  {
    Serial.println(">> Calibración cargada de memoria.");
  }
  else
  {
    Serial.println(">> No existe calibración guardada. Necesitas presionar el botón.");
  }

  // ======== Inicializar Motores y Encoders ========
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);

  setupMotorPWM(PWMA, CH_A, 0);
  setupMotorPWM(PWMB, CH_B, 1);

  pinMode(R_A, INPUT_PULLUP);
  pinMode(R_B, INPUT_PULLUP);
  pinMode(L_A, INPUT_PULLUP);
  pinMode(L_B, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(R_A), isr_RA, CHANGE);
  attachInterrupt(digitalPinToInterrupt(L_A), isr_LA, CHANGE);
  // CONFIGURACION DE LA RED NEURONAL
  // Crear e inicializar el array de los datos de entrada
  XI.NewArray_2D(1, 3);
  XI.ToinitializeArray_2D(0.0);
  // Crear e inicializar el array de salidas deseadas
  D.NewArray_2D(1, 1);
  D.ToinitializeArray_2D(0.0);
  // Columnas de XI
  byte XC = XI.GetColumns();
  // Filas de D
  byte DF = D.GetRows();
  // Filas de XI
  byte XF = XI.GetRows();
  // Definomos numero de capas
  byte L = 3;
  // Creamos e inicializamos el array donde se guardara
  // la estructura de la red
  EST.NewArray_2D(1, L);
  EST.ToinitializeArray_2D(0.0);
  float NC = EST.GetColumns();
  // Vector que contiene la estructura de la red
  float V[] = {XC, 3, DF};
  // Copiamos el vector al array
  for (byte i = 0; i < NC; i++)
  {
    EST.WriteArray_2D(0, i, V[i]);
  }
  // creamos array tipo string para pasar
  // las funciones de activacion
  FAC_STR.CharNewArray_1D(L);
  // Vector que contine las funciones de activacion
  char *myStrings[] = {"logsig", "logsig", "poslin_lim"};
  // Copiamos el vector al array
  for (byte i = 0; i < FAC_STR.GetRows(); i++)
  {
    FAC_STR.CharWriteArray_1D(i, myStrings[i]);
  }
  net.dposlin_limits(1, -1);
  // Creamos la red
  net.LearningRate = 0.00;
  net.FEED_FORWARD_NET(EST, FAC_STR);
  posicion.NewArray_2D(1, 1);
  posicion.ToinitializeArray_2D(0.0);
  // Variable de entrenamiento
  net.LearningRate = 0.025; // 0.025;
  setPointMPU = 0.400;
  // Sensores de línea
  for (int i = 0; i < NUM_SENSORS; i++)
    pinMode(sensorPins[i], INPUT);

  // Si ya existe calibración → calcula ángulo inicial
  if (loadCalibration())
  {
    int16_t ax_init, ay_init, az_init;
    mpu.getAcceleration(&ax_init, &ay_init, &az_init);
    angleFiltered = atan2(
                        (ay_init - ay_offset) / 16384.0,
                        (az_init - az_offset) / 16384.0) *
                    180.0 / PI;
  }

  // ======== CREAR TAREAS ========
  xTaskCreatePinnedToCore(TaskBalanceo, "TaskBalanceo", 10000, NULL, 3, &taskBalHandle, 1);
  xTaskCreatePinnedToCore(TaskLinea, "TaskLinea", 4000, NULL, 1, &taskLineHandle, 0);

  Serial.println("Robot listo. Presiona el botón para calibrar la MPU.");
}

void loop()
{
  // Detecta si el botón está presionado (pin 10 a GND)
  if (digitalRead(BTN_CAL) == LOW)
  {
    Serial.println(">> Botón presionado. Deteniendo robot para calibrar...");

    stopRobotAndTasks(); // apaga motores + suspende tareas
    delay(50);           // pequeño debounce / asegurar suspensión

    Serial.println(">> Iniciando calibración MPU...");
    calibrateMPU(); // hace la calibración (usa delay internamente)
    Serial.println(">> Calibración MPU completa y guardada.");

    delay(50);

    resumeRobotAndTasks(); // reactiva tareas y motores
    Serial.println(">> Robot reanudado.");

     vTaskDelay(pdMS_TO_TICKS(10)); // 10 ms
  }
>>>>>>> ec42d93 (Inicial all)
=======
>>>>>>> e23c40d (New Version)
}