#include <Arduino.h>
#include "Neural_Networks_FF.h"
#include <Wire.h>
#include <MPU6050.h>
#include <driver/ledc.h>
#include <PID_v1.h>
#include <Preferences.h>

// ================= BOTÓN ===============
#define BTN_CAL 10
Preferences prefs;
bool calibratedOnce = false;

// Handles para poder suspender/reanudar tareas
TaskHandle_t taskBalHandle = NULL;
TaskHandle_t taskLineHandle = NULL;

// ===================== PINES MOTORES ==========================
#define AIN1 7
#define AIN2 6
#define PWMA 5
#define BIN1 16
#define BIN2 17
#define PWMB 18
#define STBY 15

// Contructor de la red neuronal
Neural_Networks_FF net = Neural_Networks_FF();
// Array dinamico para ingresar las entradas a la red
Dynamic_Array XI = Dynamic_Array();
// Array dinamico para ingresar las salidas deseadas
Dynamic_Array D = Dynamic_Array();
// Array dinamico tipo string para ingresar las funciones de activacion por capa
Dynamic_Array FAC_STR = Dynamic_Array();
// Array dinamico para ingresar la estructura de la red como vector
Dynamic_Array EST = Dynamic_Array();
Dynamic_Array posicion = Dynamic_Array();

// ===================== PWM ====================================
#define PWM_FREQ 20000
#define PWM_RES 8
const ledc_channel_t CH_A = LEDC_CHANNEL_0; // Motor Izquierdo (A)
const ledc_channel_t CH_B = LEDC_CHANNEL_1; // Motor Derecho (B)

// ===================== PINES ENCODERS ==========================
#define R_A 3
#define R_B 46
#define L_A 9
#define L_B 11

volatile long countR = 0;
volatile long countL = 0;

const int CPR = 44;
// =====================  Variables para el control RN ==========================

float vel = 0.00;
float error = 0.00;
float error_1 = 0.00;
float error_2 = 0.00;
float setPoint = 0.000;
float Output = 0.00;

// ===================== MPU ====================================
MPU6050 mpu;
float ax_offset = 0, ay_offset = 0, az_offset = 0;
float gx_offset = 0;

// ===================== FILTRO =================================
float angleFiltered = 0;

// ===================== CONTROL EN CASCADA (BALANCEO) ======================
float setpoint_angle = 0.7;
float Kp_angle = 85;  // 80
float Ki_angle = 1.0; // 1
float Kd_angle = 1.6; // Pruebalo 1

float angle_integral = 0;
float angle_prev_error = 0;

float Kp_speed = 0.8; // 0.8
float Ki_speed = 0.000001;
float speed_integral = 0;

float MAX_ANGLE = 40;
float PWM_LIMIT = 255;

// ===================== SEGUIDOR DE LÍNEA ======================
#define NUM_SENSORS 8
// const uint8_t sensorPins[NUM_SENSORS] = { 40, 38, 37, 36, 35, 0, 45, 48 };
const uint8_t sensorPins[NUM_SENSORS] = {48, 45, 0, 35, 36, 37, 38, 40};

// La salida del PID de línea.
// Valor de 0.0 es centro. +/- 0.25 es el giro máximo permitido.
volatile float factor_giro = 0.0;

// PID Línea
double lineInput = 0;
double lineOutput = 0;
double lineSetpoint = 350; // centro ideal (0..700)

double Kp_line = 30;
double Ki_line = 0.001;
double Kd_line = 10;

// Nota: Puedes necesitar ajustar Kp_line si la respuesta es muy fuerte o suave.
PID pidLinea(&lineInput, &lineOutput, &lineSetpoint, Kp_line, Ki_line, Kd_line, DIRECT);

// ===================== ISRs ENCODER ============================
void IRAM_ATTR isr_RA()
{
  if (digitalRead(R_A) == digitalRead(R_B))
    countR++;
  else
    countR--;
}

void IRAM_ATTR isr_LA()
{
  if (digitalRead(L_A) == digitalRead(L_B))
    countL++;
  else
    countL--;
}

// ===================== PWM MOTOR ===============================
void setupMotorPWM(int pwmPin, int pwmChannel, int timerNum)
{
  ledc_timer_config_t timer_conf = {
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .duty_resolution = LEDC_TIMER_8_BIT,
      .timer_num = (ledc_timer_t)timerNum,
      .freq_hz = PWM_FREQ,
      .clk_cfg = LEDC_AUTO_CLK};

  ledc_timer_config(&timer_conf);

  ledc_channel_config_t channel_conf = {
      .gpio_num = pwmPin,
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .channel = (ledc_channel_t)pwmChannel,
      .intr_type = LEDC_INTR_DISABLE,
      .timer_sel = (ledc_timer_t)timerNum,
      .duty = 0};

  ledc_channel_config(&channel_conf);
}

/**
 * @brief Aplica PWMs diferenciales a los dos motores.
 * @param pwmL PWM para el motor izquierdo (CH_A)
 * @param pwmR PWM para el motor derecho (CH_B)
 */
void driveMotorsDifferential(float pwmL, float pwmR)
{
  digitalWrite(STBY, HIGH);

  // --- MOTOR IZQUIERDO (CH_A) ---
  int dutyL = constrain(abs(pwmL), 0, 255);

  // Lógica de dirección: Asumimos que HIGH/LOW para AIN2/AIN1 es adelante
  if (pwmL > 0)
  { // Adelante
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
  }
  else
  { // Atrás
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, dutyL);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);

  //--- MOTOR DERECHO (CH_B) ---
  int dutyR = constrain(abs(pwmR), 0, 255);

  // Lógica de dirección: Asumimos que HIGH/LOW para BIN2/BIN1 es adelante
  if (pwmR > 0)
  { // Adelante
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
  }
  else
  { // Atrás
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
  }
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, dutyR);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);
}

// ===================== CONTROL EN CASCADA ======================
float cascada(float angle, float rpmLeft, float rpmRight, float dt)
{
  float derivative = (error - angle_prev_error) / dt;
  posicion.WriteArray_2D(0, 0, angle / 100.00);
  error = setpoint_angle - angle;
  XI.WriteArray_2D(0, 0, error);
  XI.WriteArray_2D(0, 1, error - error_1);
  XI.WriteArray_2D(0, 2, error_1 - error_2);
  // net.DATA_CENTERING(XI);
  net.NORMALIZE_DATA(XI, 100.00);
  D.WriteArray_2D(0, 0, setPoint / 100.00);
  net.TRAIN_NET_ONLINE(XI, D, posicion);
  Output = net.y.ReadArray_2D(net.y.GetRows() - 1, 0);
  error_2 = error_1;
  error_1 = error;
  Kp_angle = Output * 100;

  float pid_unsat = Kp_angle * error + Ki_angle * angle_integral + Kd_angle * derivative;

  // Lazo interno: Salida es la REFERENCIA DE VELOCIDAD
  float speed_ref = constrain(pid_unsat, -300, 300);
  if (!((pid_unsat != speed_ref) && (error * pid_unsat) > 0))
  {
    angle_integral += error * dt;
  }
  angle_prev_error = error;
  // Lazo externo: PID de Velocidad
  float speed_measured = (rpmLeft + rpmRight) * 0.5;
  float error_speed = speed_ref - speed_measured;

  // Salida es el PWM BASE que se necesita para mantener la velocidad
  float pwm_unsat = Kp_speed * error_speed + Ki_speed * speed_integral;
  float pwm_balanceo_base = constrain(pwm_unsat, -PWM_LIMIT, PWM_LIMIT);

  if (!((pwm_unsat != pwm_balanceo_base) && (error_speed * pwm_unsat) > 0))
  {
    speed_integral += error_speed * dt;
  }

  speed_integral = constrain(speed_integral, -150, 150);

  if (abs(angle) > MAX_ANGLE)
    return 0;
  return pwm_balanceo_base;
}

void saveCalibration()
{
  prefs.begin("mpu", false);
  prefs.putFloat("ax_off", ax_offset);
  prefs.putFloat("ay_off", ay_offset);
  prefs.putFloat("az_off", az_offset);
  prefs.putFloat("gx_off", gx_offset);
  prefs.end();
  Serial.println(">> Calibración guardada.");
}

bool loadCalibration()
{
  prefs.begin("mpu", true);
  if (!prefs.isKey("ax_off"))
  {
    prefs.end();
    return false;
  }
  ax_offset = prefs.getFloat("ax_off");
  ay_offset = prefs.getFloat("ay_off");
  az_offset = prefs.getFloat("az_off");
  gx_offset = prefs.getFloat("gx_off");
  prefs.end();
  return true;
}

void calibrateMPU()
{
  Serial.println(">> Iniciando calibración MPU...");

  long ax_sum = 0, ay_sum = 0, az_sum = 0, gx_sum = 0;
  const int samples = 500;

  for (int i = 0; i < samples; i++)
  {
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    ax_sum += ax;
    ay_sum += ay;
    az_sum += az;
    gx_sum += gx;
    delay(3);
  }

  ax_offset = ax_sum / samples;
  ay_offset = ay_sum / samples;
  az_offset = (az_sum / samples) - 16384;
  gx_offset = gx_sum / samples;

  saveCalibration();
  Serial.println(">> Calibración MPU COMPLETA.");
}

// ===================== TASK BALANCEO ===========================
void TaskBalanceo(void *pvParameters)
{
  const TickType_t dt_task = pdMS_TO_TICKS(20);

  while (true)
  {
    // La MPU, el filtro y el cálculo de RPM quedan IGUAL
    // ... (Código MPU/Filtro/RPM) ...

    float dt = 0.020;
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    float accelY = (ay - ay_offset) / 16384.0;
    float accelZ = (az - az_offset) / 16384.0;
    float gyroX = (gx - gx_offset) / 131.0;
    float angleAcc = atan2(accelY, accelZ) * 180.0 / PI;
    angleFiltered = 0.98 * (angleFiltered + gyroX * dt) + 0.02 * angleAcc;

    long pulsesR = countR;
    long pulsesL = countL;
    countR = 0;
    countL = 0;

    const float PPR = 44.0 * 119.0;
    float revR = pulsesR / PPR;
    float revL = pulsesL / PPR;
    float rpmR = (revR / dt) * 60.0;
    float rpmL = (revL / dt) * 60.0;

    static float rpmR_f = 0, rpmL_f = 0;
    rpmR_f = 0.7 * rpmR_f + 0.3 * rpmR;
    rpmL_f = 0.7 * rpmL_f + 0.3 * rpmL;

    // ---- CONTROL DE BALANCEO: Obtiene el PWM BASE ----
    float pwm_balanceo_base = cascada(angleFiltered, rpmL_f, rpmR_f, dt);

    // ---- FUSIÓN MULTIPLICATIVA DE LA LÍNEA ----
    // La magnitud del factor_giro (ej. 0.25) determina el giro máximo.
    // Si factor_giro > 0, necesita girar a la izquierda (Aumentar L, reducir R).
    // Si factor_giro < 0, necesita girar a la derecha (Reducir L, aumentar R).

    float factorL = 1.0 + factor_giro;
    float factorR = 1.0 - factor_giro;

    float pwm_finalL = pwm_balanceo_base * factorL;
    float pwm_finalR = pwm_balanceo_base * factorR;

    // Recortar al límite absoluto de PWM_LIMIT (255)
    pwm_finalL = constrain(pwm_finalL, -PWM_LIMIT, PWM_LIMIT);
    pwm_finalR = constrain(pwm_finalR, -PWM_LIMIT, PWM_LIMIT);

    // ---- ACTUACIÓN ----
    driveMotorsDifferential(pwm_finalL, pwm_finalR);

    // Debug
    Serial.print("Ang: ");
    Serial.print(angleFiltered);
    Serial.print(" | PWM Base: ");
    Serial.print(pwm_balanceo_base);
    Serial.print(" | Factor G: ");
    Serial.print(factor_giro);
    Serial.print(" | PWM L: ");
    Serial.print(pwm_finalL);
    Serial.print(" | PWM R: ");
    Serial.println(pwm_finalR);

    vTaskDelay(dt_task);
  }
}

// ===================== TASK LÍNEA ==============================
void TaskLinea(void *pvParameters)
{
  pidLinea.SetMode(AUTOMATIC);
  // La salida se limita a un valor que represente el porcentaje de giro máximo.
  pidLinea.SetOutputLimits(-0.40, 0.40); // Ej. Máx. 25% de corrección.
  pidLinea.SetSampleTime(100);

  while (true)
  {
    int suma = 0;
    int pos = 0;
    int num_blancos = 0;

    for (int i = 0; i < NUM_SENSORS; i++)
    {
      // Asumes negro=LOW (1)
      int val = digitalRead(sensorPins[i]) == LOW ? 1 : 0;
      suma += val;
      pos += val * i * 100; // Posición ponderada (0, 100, 200... 700)
      if (val == 0)
        num_blancos++;
    }

    if (suma > 0)
    {
      lineInput = (double)(pos / suma); // 0 - 700
      pidLinea.Compute();
      factor_giro = (float)lineOutput; // La corrección PID es el factor
    }
    else
    {
      // Si no detecta la línea (suma=0), el robot avanza recto (factor_giro = 0)
      factor_giro = 0;
    }

    // NOTA: Si necesitas que el robot "busque" la línea cuando se pierde,
    // tendrías que usar un PID de "Pérdida de Línea" aquí, manteniendo la
    // última dirección conocida. Por ahora, se detiene la corrección de giro.

    // Debug línea
    static unsigned long lastPrint = 0;
    if (millis() - lastPrint > 200)
    {
      lastPrint = millis();
      Serial.print("LINE POS: ");
      Serial.print(lineInput);
      Serial.print(" | PID OUT: ");
      Serial.print(lineOutput);
      Serial.print(" | FACTOR GIRO: ");
      Serial.println(factor_giro);
    }

    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

// Detiene físicamente los motores y suspende las tareas relevantes
void stopRobotAndTasks()
{
  // Apagar PWM (poner duty 0)
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_A, 0);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_A);
  ledc_set_duty(LEDC_LOW_SPEED_MODE, CH_B, 0);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, CH_B);

  // Opcional: desactivar STBY si tu driver lo soporta (evita que se energicen los H-bridges)
  digitalWrite(STBY, LOW);

  // Suspender sólo las tareas que usamos
  if (taskBalHandle != NULL)
    vTaskSuspend(taskBalHandle);
  if (taskLineHandle != NULL)
    vTaskSuspend(taskLineHandle);

  // Pequeña espera para asegurar que tareas se suspendan
  delay(20);
}

// Reactiva tareas y vuelve a permitir movimiento
void resumeRobotAndTasks()
{
  // Reactivar tareas primero (para que arranquen sus loops)
  if (taskLineHandle != NULL)
    vTaskResume(taskLineHandle);
  if (taskBalHandle != NULL)
    vTaskResume(taskBalHandle);

  // Rehabilitar STBY para permitir motores
  digitalWrite(STBY, HIGH);

  // Espera para que las tareas estabilicen antes de permitir movimiento
  delay(20);
}

// ===================== SETUP ===================================
void setup()
{
  Serial.begin(115200);
  Wire.begin(41, 42);
  mpu.initialize();

  pinMode(BTN_CAL, INPUT_PULLUP); // Botón hacia GND

  // ======== CARGAR CALIBRACIÓN GUARDADA =========
  if (loadCalibration())
  {
    Serial.println(">> Calibración cargada de memoria.");
  }
  else
  {
    Serial.println(">> No existe calibración guardada. Necesitas presionar el botón.");
  }

  // ======== Inicializar Motores y Encoders ========
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);

  setupMotorPWM(PWMA, CH_A, 0);
  setupMotorPWM(PWMB, CH_B, 1);

  pinMode(R_A, INPUT_PULLUP);
  pinMode(R_B, INPUT_PULLUP);
  pinMode(L_A, INPUT_PULLUP);
  pinMode(L_B, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(R_A), isr_RA, CHANGE);
  attachInterrupt(digitalPinToInterrupt(L_A), isr_LA, CHANGE);
  // CONFIGURACION DE LA RED NEURONAL
  // Crear e inicializar el array de los datos de entrada
  XI.NewArray_2D(1, 3);
  XI.ToinitializeArray_2D(0.0);
  // Crear e inicializar el array de salidas deseadas
  D.NewArray_2D(1, 1);
  D.ToinitializeArray_2D(0.0);
  // Columnas de XI
  byte XC = XI.GetColumns();
  // Filas de D
  byte DF = D.GetRows();
  // Filas de XI
  byte XF = XI.GetRows();
  // Definomos numero de capas
  byte L = 3;
  // Creamos e inicializamos el array donde se guardara
  // la estructura de la red
  EST.NewArray_2D(1, L);
  EST.ToinitializeArray_2D(0.0);
  float NC = EST.GetColumns();
  // Vector que contiene la estructura de la red
  float V[] = {XC, 3, DF};
  // Copiamos el vector al array
  for (byte i = 0; i < NC; i++)
  {
    EST.WriteArray_2D(0, i, V[i]);
  }
  // creamos array tipo string para pasar
  // las funciones de activacion
  FAC_STR.CharNewArray_1D(L);
  // Vector que contine las funciones de activacion
  char *myStrings[] = {"logsig", "logsig", "poslin_lim"};
  // Copiamos el vector al array
  for (byte i = 0; i < FAC_STR.GetRows(); i++)
  {
    FAC_STR.CharWriteArray_1D(i, myStrings[i]);
  }
  net.dposlin_limits(1, -1);
  // Creamos la red
  net.LearningRate = 0.00;
  net.FEED_FORWARD_NET(EST, FAC_STR);
  posicion.NewArray_2D(1, 1);
  posicion.ToinitializeArray_2D(0.0);
  // Variable de entrenamiento
  net.LearningRate = 2.25; // 0.025;
  setPoint = 0.700;
  // Sensores de línea
  for (int i = 0; i < NUM_SENSORS; i++)
    pinMode(sensorPins[i], INPUT);

  // Si ya existe calibración → calcula ángulo inicial
  if (loadCalibration())
  {
    int16_t ax_init, ay_init, az_init;
    mpu.getAcceleration(&ax_init, &ay_init, &az_init);
    angleFiltered = atan2(
                        (ay_init - ay_offset) / 16384.0,
                        (az_init - az_offset) / 16384.0) *
                    180.0 / PI;
  }

  // ======== CREAR TAREAS ========
  xTaskCreatePinnedToCore(TaskBalanceo, "TaskBalanceo", 10000, NULL, 3, &taskBalHandle, 1);
  xTaskCreatePinnedToCore(TaskLinea, "TaskLinea", 4000, NULL, 1, &taskLineHandle, 0);

  Serial.println("Robot listo. Presiona el botón para calibrar la MPU.");
}

void loop()
{
  // Detecta si el botón está presionado (pin 10 a GND)
  if (digitalRead(BTN_CAL) == LOW)
  {
    Serial.println(">> Botón presionado. Deteniendo robot para calibrar...");

    stopRobotAndTasks(); // apaga motores + suspende tareas
    delay(50);           // pequeño debounce / asegurar suspensión

    Serial.println(">> Iniciando calibración MPU...");
    calibrateMPU(); // hace la calibración (usa delay internamente)
    Serial.println(">> Calibración MPU completa y guardada.");

    delay(50);

    resumeRobotAndTasks(); // reactiva tareas y motores
    Serial.println(">> Robot reanudado.");

    delay(500); // anti-rebote para no volver a entrar inmediatamente
  }
}